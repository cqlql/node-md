import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{a,e as r,o}from"./app-C4Nz-QBA.js";const l={};function n(i,e){return o(),a("div",null,e[0]||(e[0]=[r('<h2 id="进程线程理解" tabindex="-1"><a class="header-anchor" href="#进程线程理解"><span>进程线程理解</span></a></h2><p>一个程序就是一个进程。一个进程有一个主线程，还可以拥有多个工作线程</p><h2 id="线程池" tabindex="-1"><a class="header-anchor" href="#线程池"><span>线程池</span></a></h2><ol><li>交给系统管理线程。这样能够更专注应用程序任务，而非线程管理。</li><li>一旦线程池中的线程完成任务，它将返回等待队列中，等需要时继续重用。避免创建新线程的开销。</li><li>一个进程只有一个线程池。</li><li>线程数受内存限制，如果所有线程忙碌，则会进入排队。 <ol><li><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.threadpool.getmaxthreads?view=net-7.0" target="_blank" rel="noopener noreferrer">ThreadPool.GetMaxThreads</a> 获取最大线程数。</li><li><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.threadpool.setmaxthreads?view=net-7.0" target="_blank" rel="noopener noreferrer">ThreadPool.SetMaxThreads</a> 设置最大线程数。</li></ol></li><li>Task 使用的是线程池中的线程</li></ol>',4)]))}const p=t(l,[["render",n],["__file","01_理解.html.vue"]]),d=JSON.parse('{"path":"/DotNet/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E4%BB%BB%E5%8A%A1/01_%E7%90%86%E8%A7%A3.html","title":"","lang":"zh-CN","frontmatter":{"description":"进程线程理解 一个程序就是一个进程。一个进程有一个主线程，还可以拥有多个工作线程 线程池 交给系统管理线程。这样能够更专注应用程序任务，而非线程管理。 一旦线程池中的线程完成任务，它将返回等待队列中，等需要时继续重用。避免创建新线程的开销。 一个进程只有一个线程池。 线程数受内存限制，如果所有线程忙碌，则会进入排队。 ThreadPool.GetMax...","head":[["meta",{"property":"og:url","content":"http://docs.cqlql.top/DotNet/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E4%BB%BB%E5%8A%A1/01_%E7%90%86%E8%A7%A3.html"}],["meta",{"property":"og:site_name","content":"开发笔记"}],["meta",{"property":"og:description","content":"进程线程理解 一个程序就是一个进程。一个进程有一个主线程，还可以拥有多个工作线程 线程池 交给系统管理线程。这样能够更专注应用程序任务，而非线程管理。 一旦线程池中的线程完成任务，它将返回等待队列中，等需要时继续重用。避免创建新线程的开销。 一个进程只有一个线程池。 线程数受内存限制，如果所有线程忙碌，则会进入排队。 ThreadPool.GetMax..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2022-11-23T16:18:41.000Z"}],["meta",{"property":"article:modified_time","content":"2022-11-23T16:18:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2022-11-23T16:18:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Joly\\",\\"url\\":\\"\\"}]}"]]},"headers":[{"level":2,"title":"进程线程理解","slug":"进程线程理解","link":"#进程线程理解","children":[]},{"level":2,"title":"线程池","slug":"线程池","link":"#线程池","children":[]}],"git":{"createdTime":1669101582000,"updatedTime":1669220321000,"contributors":[{"name":"陈桥黎","email":"cql.ql@qq.com","commits":2}]},"readingTime":{"minutes":0.62,"words":187},"filePathRelative":"DotNet/多线程、异步、任务/01_理解.md","localizedDate":"2022年11月22日","autoDesc":true,"excerpt":"<h2>进程线程理解</h2>\\n<p>一个程序就是一个进程。一个进程有一个主线程，还可以拥有多个工作线程</p>\\n<h2>线程池</h2>\\n<ol>\\n<li>交给系统管理线程。这样能够更专注应用程序任务，而非线程管理。</li>\\n<li>一旦线程池中的线程完成任务，它将返回等待队列中，等需要时继续重用。避免创建新线程的开销。</li>\\n<li>一个进程只有一个线程池。</li>\\n<li>线程数受内存限制，如果所有线程忙碌，则会进入排队。\\n<ol>\\n<li><a href=\\"https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.threadpool.getmaxthreads?view=net-7.0\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">ThreadPool.GetMaxThreads</a> 获取最大线程数。</li>\\n<li><a href=\\"https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.threadpool.setmaxthreads?view=net-7.0\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">ThreadPool.SetMaxThreads</a> 设置最大线程数。</li>\\n</ol>\\n</li>\\n<li>Task 使用的是线程池中的线程</li>\\n</ol>"}');export{p as comp,d as data};
