import{_ as n,Z as t,$ as l,a0 as e,a1 as a,Y as o,a2 as d,E as i}from"./framework-d33190a3.js";const c={},s=d('<p>当所有前台进程运行完成，应用程序就会关闭，所有相关的后台进程不管有没运行完，也会随之关闭。</p><ol><li>什么时候使用前台进程？ <ol><li>执行确实想完成的任务，比如数据的拷贝等等。</li><li>需要长时间等待的任务，比如监听客户端请求</li></ol></li><li>什么时候使用后台进程？ <ol><li>一般用于处理时间较短的任务，比如处理客户端发过来的请求信息。</li></ol></li><li>用 Thread 创建的线程，默认为<strong>前台线程</strong>。可通过 Thread.IsBackground 设置为后台线程。 <ol><li>所以**如何创建前台线程？**只能通过 <code>new Thread</code> 创建。</li></ol></li><li>线程池线程也就是使用 ThreadPool.QueueUserWorkItem()和Task工厂创建的线程都固定为<strong>后台线程</strong>，无法设置。</li></ol><h2 id="专用线程和线程池线程" tabindex="-1"><a class="header-anchor" href="#专用线程和线程池线程" aria-hidden="true">#</a> 专用线程和线程池线程</h2><p>使用 new Thread 创建的是专用线程</p><h2 id="疑问解答" tabindex="-1"><a class="header-anchor" href="#疑问解答" aria-hidden="true">#</a> 疑问解答</h2><ol><li>担心后台线程随时关闭？ 只需要担心的那种随着执行完成自动退出的程序，这时就要考虑后台进程关闭问题。（一般程序都是主进程一直跑的，除非手动终止，这种情况主进程都没跑完）</li></ol><h2 id="参考文档" tabindex="-1"><a class="header-anchor" href="#参考文档" aria-hidden="true">#</a> 参考文档</h2>',7),h={href:"https://cloud.tencent.com/developer/article/1410874",target:"_blank",rel:"noopener noreferrer"},_={href:"https://learn.microsoft.com/zh-cn/dotnet/standard/threading/foreground-and-background-threads",target:"_blank",rel:"noopener noreferrer"};function p(f,u){const r=i("ExternalLinkIcon");return t(),l("div",null,[s,e("p",null,[e("a",h,[a("前台线程和后台线程总结"),o(r)])]),e("p",null,[e("a",_,[a("前台线程和后台线程"),o(r)])])])}const g=n(c,[["render",p],["__file","前台线程和后台线程.html.vue"]]);export{g as default};
