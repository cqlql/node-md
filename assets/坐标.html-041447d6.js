import{_ as e,Z as a,$ as n,a2 as s}from"./framework-d33190a3.js";const t={},r=s(`<h2 id="光标、触摸点坐标" tabindex="-1"><a class="header-anchor" href="#光标、触摸点坐标" aria-hidden="true">#</a> 光标、触摸点坐标</h2><h3 id="所在元素-offsetx-offsety" tabindex="-1"><a class="header-anchor" href="#所在元素-offsetx-offsety" aria-hidden="true">#</a> 所在元素: offsetX | offsetY</h3><p><strong>说明：</strong><br> 光标或者触摸点位于当前所在元素坐标获取<br> 强调：<br> 这个所在元素包括任意任何，定位的，无定位的元素。ie67 只包括定位元素</p><p><strong>兼容性：</strong><br> ie 全系列：边框内边 起始<br> Chrome\\Safari：边框外边 起始<br> Opera：外补丁内边<br> Firefox：不支持(新版火狐，39 版本支持)<br> ie7 的另外问题：元素有滚动条情况，将获取 边框内边起始距离 + 滚动条隐藏距离</p><h3 id="定位元素-layerx-layery" tabindex="-1"><a class="header-anchor" href="#定位元素-layerx-layery" aria-hidden="true">#</a> 定位元素：layerX \\ layerY</h3><p><strong>说明：</strong><br> 相对于 当前所在元素往上最近的定位元素(包括当前所在元素)<br> 定位元素包括：absolute\\relative\\fixed,也包括 overflow 非 visible 值的元素<br> 往上都没有定位元素情况：浏览器内容窗口 起始</p><p>absolute\\relative 与 fixed 区别：起始位置<br> absolute\\relative ：边框外边起始<br> fixed：元素初始位置(滚动条在初始位置情况) 的边框外边起始<br> 总结：本质上 absolute\\relative 定位的元素一直都在初始位置上，某种意义上没有区别</p><p><strong>兼容性：</strong><br> ie6\\ie7\\ie8\\Opera：不支持</p><h3 id="内容-pagex-pagey" tabindex="-1"><a class="header-anchor" href="#内容-pagex-pagey" aria-hidden="true">#</a> 内容：pageX | pageY</h3><p><strong>说明：</strong><br> 光标相对于内容区域坐标</p><p><strong>兼容性：</strong><br> ie6\\7\\8：不支持</p><p><strong>ie6\\7\\8 偏门 实现：</strong></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>scrollLeft <span class="token operator">+</span> e<span class="token punctuation">.</span>clientX
document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>scrollTop <span class="token operator">+</span> e<span class="token punctuation">.</span>clientY
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>应用：</strong></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>box<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function-variable function">onmousemove</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  e <span class="token operator">=</span> e <span class="token operator">||</span> window<span class="token punctuation">.</span>event

  <span class="token keyword">var</span> pageX <span class="token operator">=</span> e<span class="token punctuation">.</span>pageX <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>scrollLeft <span class="token operator">+</span> e<span class="token punctuation">.</span>clientX <span class="token operator">:</span> e<span class="token punctuation">.</span>pageX
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="显示-clientx-clienty" tabindex="-1"><a class="header-anchor" href="#显示-clientx-clienty" aria-hidden="true">#</a> 显示：clientX\\ clientY</h3><p><strong>说明：</strong><br> 光标相对于显示区域坐标</p><p><strong>兼容性：</strong><br> 所有浏览器都支持<br> ie6\\7 有点问题：考虑黑边 的 2px。ie6 消掉黑边即可</p><h3 id="显示-内容-元素-x-y" tabindex="-1"><a class="header-anchor" href="#显示-内容-元素-x-y" aria-hidden="true">#</a> 显示 | 内容 | 元素：x | y</h3><p>ie6\\ie7\\Safari\\Chrome\\Opera，固定是显示。另外 ie6\\7 考虑黑边<br> ie8，固定是内容<br> ie9，光标所在元素定位属性决定。absolute--内容，static\\fixed—显示，relative—所在元素<br> Firefox，不支持</p><h3 id="屏幕-screenx-screeny" tabindex="-1"><a class="header-anchor" href="#屏幕-screenx-screeny" aria-hidden="true">#</a> 屏幕：screenX | screenY</h3><p>兼容性：所有浏览器</p><h2 id="元素坐标" tabindex="-1"><a class="header-anchor" href="#元素坐标" aria-hidden="true">#</a> 元素坐标</h2><h3 id="相对定位元素" tabindex="-1"><a class="header-anchor" href="#相对定位元素" aria-hidden="true">#</a> 相对定位元素</h3><p>offsetLeft offsetTop</p><p>取 相对于 定位父元素</p><p>td tr 等特殊元素 可能会是参照物</p><p>距离范围：自身边框外边——&gt;定位参照物边框内边<br> ie8\\Opera 在有参照元素的情况下，距离范围 不同：从边框外边起始——&gt;定位参照物 边框外边</p><p>一些固定取值为 0 的情况：</p><ol><li>样式 display 属性值 为 none</li><li>对象 被动态 创建后 并没有插入 html 中</li><li>操作的是内联元素</li></ol><p>body、html 的 offsetLeft offsetTop 不同浏览器会有差异，而且一般不会这么用，不讨论了</p><p><strong>transform 是否可通过 offsetLeft 获取？</strong><br> offsetLeft 只能获取 relative 或者 absolute 的 left top transform 可通过 getBoundingClientRect | getComputedStyle 获取</p><h3 id="应用-相对内容窗口" tabindex="-1"><a class="header-anchor" href="#应用-相对内容窗口" aria-hidden="true">#</a> [应用]相对内容窗口</h3><p>通过 offsetParent 实现<br> 可取 offsetLeft,offsetTop 值的 参照元素对象，循环便可得到 相对内容坐标了<br> 兼容性：包括 ie6 的所有</p><p><strong>fixed 的特殊性：</strong><br> offsetParent 固定返回 null</p><p>offsetTop 直接就能获取相对于视窗坐标，但只能是视窗，不考虑滚动条。</p><p>如果要获取相对于内容窗口坐标，需加上滚动条：<br> fixedElem.offsetTop + window.pageYOffset</p><h3 id="松开事件-坐标有没有偏移" tabindex="-1"><a class="header-anchor" href="#松开事件-坐标有没有偏移" aria-hidden="true">#</a> [松开事件]坐标有没有偏移</h3><p><strong>疑问：</strong><br> 惯性拖 松开后，是否与最后的移动值不同。<br><strong>结论：</strong><br> 点下是多少，松开时就是多少。<br> 由于 ie678 的实现方式不同，所以得的值不一样，但还是与最后的移动事件的值一致的(触摸也如此)。<br><strong>[速率计算] 总结：</strong><br> 速率计算，应考虑松开时的时间，以及最后移动的位置。不应考虑松开时的位置(因为没有意义)</p><p><strong>[移动松开]总结：</strong>(包括触摸)<br> 松开时光标坐标值并没有发生偏移。如果偏移了，那都得先触发移动事件</p><p><strong>最终总结：</strong><br> 松开事件没有发生坐标偏移。在发生偏移后，松开事件的坐标等于移动事件里面最后的坐标<br> 这里说的松开事件包括触摸松开</p><h3 id="取元素区块坐标尺寸" tabindex="-1"><a class="header-anchor" href="#取元素区块坐标尺寸" aria-hidden="true">#</a> 取元素区块坐标尺寸</h3><p>这将获取精确的坐标，且支持 transform</p><p><strong>区块坐标尺寸说明</strong></p><p>xy 坐标： 相对于浏览器窗口坐标。 强调，此坐标不包含窗口滚动条卷去高度，也就是相当于： 相对内容窗口 Y 坐标-窗口滚动条卷去高度(window.pageYOffset)</p><p>尺寸： 元素所占面积，包括边框，不包括外补白</p><p>getBoundingClientRect：取当前元素所占区块对象，包括了尺寸和坐标。是整个元素所占的一个区块，只有一个</p><p>getClientRects：取当前元素所占的多个区块此情况一个元素会出现多个区块：某元素因文本过多而换行，一行一个区块</p><p><strong>兼容性：</strong> ie678 只有坐标，没有尺寸</p><h2 id="屏幕坐标" tabindex="-1"><a class="header-anchor" href="#屏幕坐标" aria-hidden="true">#</a> 屏幕坐标</h2><h3 id="浏览器相对于-屏幕坐标" tabindex="-1"><a class="header-anchor" href="#浏览器相对于-屏幕坐标" aria-hidden="true">#</a> 浏览器相对于 屏幕坐标</h3><p>Chrome 支持的写法<br> window.screenTop</p><p>ie9\\opera\\Chrome\\fox 支持的写法<br> window.screenY</p><h3 id="显示窗口-相对于屏幕坐标" tabindex="-1"><a class="header-anchor" href="#显示窗口-相对于屏幕坐标" aria-hidden="true">#</a> 显示窗口 相对于屏幕坐标</h3><p>ie6789\\opera<br> window.screenTop</p>`,55),o=[r];function p(i,c){return a(),n("div",null,o)}const l=e(t,[["render",p],["__file","坐标.html.vue"]]);export{l as default};
