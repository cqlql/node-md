import{_ as a,Z as r,$ as l,a0 as e,a1 as t,Y as o,E as s}from"./framework-d33190a3.js";const i={},_=e("h2",{id:"进程线程理解",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#进程线程理解","aria-hidden":"true"},"#"),t(" 进程线程理解")],-1),c=e("p",null,"一个程序就是一个进程。一个进程有一个主线程，还可以拥有多个工作线程",-1),d=e("h2",{id:"线程池",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#线程池","aria-hidden":"true"},"#"),t(" 线程池")],-1),h=e("li",null,"交给系统管理线程。这样能够更专注应用程序任务，而非线程管理。",-1),u=e("li",null,"一旦线程池中的线程完成任务，它将返回等待队列中，等需要时继续重用。避免创建新线程的开销。",-1),m=e("li",null,"一个进程只有一个线程池。",-1),f={href:"https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.threadpool.getmaxthreads?view=net-7.0",target:"_blank",rel:"noopener noreferrer"},p={href:"https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.threadpool.setmaxthreads?view=net-7.0",target:"_blank",rel:"noopener noreferrer"},x=e("li",null,"Task 使用的是线程池中的线程",-1);function k(T,g){const n=s("ExternalLinkIcon");return r(),l("div",null,[_,c,d,e("ol",null,[h,u,m,e("li",null,[t("线程数受内存限制，如果所有线程忙碌，则会进入排队。 "),e("ol",null,[e("li",null,[e("a",f,[t("ThreadPool.GetMaxThreads"),o(n)]),t(" 获取最大线程数。")]),e("li",null,[e("a",p,[t("ThreadPool.SetMaxThreads"),o(n)]),t(" 设置最大线程数。")])])]),x])])}const b=a(i,[["render",k],["__file","01_理解.html.vue"]]);export{b as default};
