

## 通过插槽向父组件传值

**current-user 组件的 template 部分**

```vue
<template>
<span>
  <slot v-bind:user="user">
    {{ user.lastName }} <!-- 这是默认插槽值（当调用此组件没有给插槽值时显示此值） -->
  </slot>

  <slot name="other" :args="args"></slot>
</span>
</template>
```

**父组件**

对 current-user 组件的调用，并通过插槽接收值

```vue
<template>
<current-user>

  <template v-slot:default="{ user }">
    {{ user.firstName }}
  </template>

  <template #other="slotProps">
    ...
  </template>
</current-user>
</template>
```


**涉及到的技术点**

插槽默认值

v-bind v-slot 可以省略

slotProps 支持解构


## 高级：通过jsx灵活分配插槽组件


也就是说，父组件可以接受子组件传过来的组件，这样可以实现自定义分配子组件内部布局，并在合适的位置插入其他元素


this.$scopedSlots.btns()


## 高级：模板中定义传递组件


```vue
<template>
  <div>
    <VNodesDefine ref="VNodesDefine">
      <!-- 这是定义的组件，此组件不会渲染，但会在其他地方调用并渲染 -->
      <el-input disabled />
    </VNodesDefine>

    <!-- 渲染模板中的组件 -->
    <VNodes :vnode="vnode"></VNodes>
  </div>
</template>

<script>
export default {
  components: {
    // 用来定义其他组件的空壳组件
    VNodesDefine: {
      render() {}, // 这里是空的，所以不会渲染出内容
    },

    // 为了能在template中通过变量形式使用其他组件
    VNodes:{
      inheritAttrs: false,
      render() {
        return this.$attrs.vnode
      },
    }
  },
  data() {
    return {
      vnode: null,
    }
  },
  mounted() {
    // 将获取到的 <el-input disabled /> 赋值给 vnode
    this.vnode = this.$refs.VNodesDefine.$scopedSlots.default()
  },
}
</script>
```
