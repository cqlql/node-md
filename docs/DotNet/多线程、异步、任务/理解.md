
## 进程线程理解

一个程序就是一个进程。一个进程有一个主线程，还可以拥有多个工作线程

## 线程池

1. 交给系统管理线程。这样能够更专注应用程序任务，而非线程管理。
2. 一旦线程池中的线程完成任务，它将返回等待队列中，等需要时继续重用。避免创建新线程的开销。
3. 一个进程只有一个线程池。
4. 线程数受内存限制，如果所有线程忙碌，则会进入排队。 
   1. [ThreadPool.GetMaxThreads](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.threadpool.getmaxthreads?view=net-7.0) 获取最大线程数。 
   2. [ThreadPool.SetMaxThreads](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.threadpool.setmaxthreads?view=net-7.0) 设置最大线程数。
5. Task 使用的是线程池中的线程

## Task
从线程池中使用一个线程

## lock 互斥锁

多线程同时访问一个资源会出问题。这时就需要 lock 锁。

应用了 lock 的变量，只有再等待此方法之前完后，才会继续执行使用了 lock 此变量的其他方法。

问题？如果 lock 外围还有其他代码？那么会与 lock 语句包裹的代码分开执行吗？

**死锁**：线程X锁定变量A，但一直没有释放锁定，导致其他线程锁定变量A时一直阻塞。

**避免死锁**：使用 Monitor.TryEnter 方法结合 try-finally 语句代替 lock，并提供超时。


```cs
using System;
using System.Threading;
using System.Threading.Tasks;
using System.Diagnostics;
using static System.Console;

namespace SynchronizingResourceAccess
{
  class Program
  {
    static Random r = new Random();
    static string Message; // a shared resource
    static int Counter; // another shared resource
    static object conch = new object();

    static void MethodA()
    {
      try
      {
        // 使用 TryEnter 并提供 15s 超时
        Monitor.TryEnter(conch, TimeSpan.FromSeconds(15));

        for (int i = 0; i < 5; i++)
        {
          Thread.Sleep(r.Next(2000));
          Message += "A";
          Interlocked.Increment(ref Counter);
          Write(".");
        }
      }
      finally
      {
        Monitor.Exit(conch);
      }
    }

    static void MethodB()
    {
      try
      {
        // 使用 TryEnter 并提供 15s 超时
        Monitor.TryEnter(conch, TimeSpan.FromSeconds(15));
        
        for (int i = 0; i < 5; i++)
        {
          Thread.Sleep(r.Next(2000));
          Message += "B";
          Interlocked.Increment(ref Counter);
          Write(".");
        }
      }
      finally
      {
        Monitor.Exit(conch);
      }
    }

    static void Main(string[] args)
    {
      WriteLine("Please wait for the tasks to complete.");
      Stopwatch watch = Stopwatch.StartNew();

      Task a = Task.Factory.StartNew(MethodA);
      Task b = Task.Factory.StartNew(MethodB);

      Task.WaitAll(new Task[] { a, b });

      WriteLine();
      WriteLine($"Results: {Message}.");
      WriteLine($"{watch.ElapsedMilliseconds:#,##0} elapsed milliseconds.");
      WriteLine($"{Counter} string modifications.");
    }
  }
}
```

## 原子操作

**原子**：不能比分割的最小粒子

**原子操作**：不能被中断的一个或一系列操作

多个线程同时进行一个操作，如果不是原子的，那么可能会出现一些意想不到的效果。



## Thread与Task的区别

Task 是 Thread 的封装，Thread 是基础

[[.NET]Thread与Task的区别 - 大杂草 - 博客园 (cnblogs.com)](https://www.cnblogs.com/liang24/p/13785480.html)

## “Task.Factory.StartNew” vs “new Task(…).Start”

`Task.Factory.StartNew` 能确保只调用一次 start，
而 `new Task(…).Start` 可能在其他地方多次调用 start，。
但有些地方还是需要 `new Task(…).Start`，见下：

```cs
// 错误的例子
 Task t = null;
t = Task.Factory.StartNew(() =>
{
    // …
      // 这里 t会被视为 null
    t.ContinueWith(/* … */);
});

// 正确的例子
Task t = null;
t = new Task(() =>
{
    // …
    t.ContinueWith(/* … */);
});
t.Start();
```

原文链接：["Task.Factory.StartNew" vs "new Task(...).Start" - .NET Parallel Programming (microsoft.com)](https://devblogs.microsoft.com/pfxteam/task-factory-startnew-vs-new-task-start/)


## Thread.Sleep

挂起当前线程的操作




