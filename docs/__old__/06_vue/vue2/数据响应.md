

## 组件之间响应传值

### 可借助引用类型特性
比如传一个响应数据对象到某子组件。
当然，子组件中直接的覆盖操作是不允许的。
但对响应对象的成员修改是能触发所有相关组件的响应更新的

## 展示页，编辑组件。技巧
一个页面，实现展示+编辑

虽然数据一样，但不能同时共享一份。因为当用于选择取消编辑便回不去了，后果很严重

展示页 可弄两份数据，一份源数据，再copy一份。将copy数据传入编辑页，再利用引用类型特性，编辑页对copy数据修改会同步到展示页。



```js
vm.$set(vm.d, 'list', list)
```

## object 增删改

### 增

**1 根成员增加**

根成员只能在 data 中以声明方式增加

```js
new Vue({
    data: {
        msg: 'hello'
    }
})
```

**2 后代成员增加**

```js
vm.$set(vm.d, 'list', list)
```

### 删

**1 根成员是否可以删除？还没试**

**2 后代成员删除**

```js
vm.$delete(target, key)
```

**注意：使用自带 delete：此方式无法触发更新**

### 改

**成员修改**
一般赋值操作即可

**自身替换**
直接赋值替换即可，后代成员都可享受响应更新

## array 增删改

### 增

可通过 object 的方式，也支持 Array 原生方法

### 删

待实践

### 改

一般方式即可

### 数组替换、数组清空

```js
vm.arr = newArr // 直接替换

vm.arr = [] // 清空
```

## 数据响应举例。watch 监听问题

### 会触发更新，并且重新绑定情况

给已绑定字段重新赋值，会触发重新绑定，字段子成员都会重新绑定


测试例子

```js
export default {
  data () {
    // 这里声明的所有属性都将绑定
    return {
      a: {
        b: {
          c: 123
        }
      }
    }
  },
  created () {

  },
  methods: {
    test () {
      // 触发更新，子成员全部重新绑定
      // 同时触发下面的 watch 更改
      this.a = {
        d: {
          e: 123
        }
      }
    }
  },
  components: {
  },
  watch: {
    'a.b' (v) {
      console.log('更改 a.b', v) // '更改 a.b', undefined
    }
  }
}
```

### 不会触发更新情况

```js
export default {
  data () {
    return {
      a: {
        b: {
          c: 123
        }
      }
    }
  },
  created () {

  },
  methods: {
    test () {
      // 新增成员不会触发更新。
      this.a.d = 123
      // 需借助 this.$set()
      this.$set(thia.a, 'd', 123) // 绑定，并触发更新
    }
  },
  components: {
  }
}
```
